/*

描述

骨牌，一种古老的玩具。今天我们要研究的是骨牌的覆盖问题：
 我们有一个2xN的长条形棋盘，然后用1x2的骨牌去覆盖整个棋盘。对于这个棋盘，一共有多少种不同的覆盖方法呢？
 举个例子，对于长度为1到3的棋盘，我们有下面几种覆盖方式： 

提示：骨牌覆盖
  
提示：如何快速计算结果
 
输入

第1行：1个整数N。表示棋盘长度。1≤N≤100,000,000

输出

第1行：1个整数，表示覆盖方案数 MOD 19999997

样例输入

62247088

样例输出

17748018
*/

/*
f(n)=f(n-1)+f(n-2)
快速幂 计算到27
*/

#include <iostream>
using namespace std;


int main()
{
	long n;
	
		cin>>n;
		long mi[29][4]={0};
		mi[0][0]=0;mi[0][1]=1;mi[0][2]=1;mi[0][3]=1;
		mi[28][0]=1;mi[28][1]=1;mi[28][2]=1;mi[28][3]=1;
		for (int i=1;i<28;i++)
		{
			mi[i][0]=(mi[i-1][0]*mi[i-1][0]+mi[i-1][1]*mi[i-1][2])%19999997;
			mi[i][1]=(mi[i-1][0]*mi[i-1][1]+mi[i-1][1]*mi[i-1][3])%19999997;
			mi[i][2]=(mi[i-1][0]*mi[i-1][2]+mi[i-1][2]*mi[i-1][3])%19999997;
			mi[i][3]=(mi[i-1][1]*mi[i-1][2]+mi[i-1][3]*mi[i-1][3])%19999997;
		}
		if (n==0)
		{
			cout<<0;			
		}else if (n==1)
		{
			cout<<1;
		}
		else {
			n--;
			for (int i=0;i<28;i++)
			{
				if ((n%2)!=0)
				{
					int temp1,temp2,temp3,temp4;
					temp1=mi[28][0];temp2=mi[28][1];temp3=mi[28][2];temp4=mi[28][3];
					mi[28][0]=(temp1*mi[i][0]+temp2*mi[i][2])%19999997;
					mi[28][1]=(temp1*mi[i][1]+temp2*mi[i][3])%19999997;
					mi[28][2]=(temp3*mi[i][0]+temp4*mi[i][2])%19999997;
					mi[28][3]=(temp3*mi[i][1]+temp4*mi[i][3])%19999997;
				}
				n=n/2;
			}																						
			cout<<mi[28][3]<<endl;
		}
	return 0;

}